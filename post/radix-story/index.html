<!DOCTYPE html>
<html lang="en-US">
<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>A Radix Story</title>

    <meta name="description" content="About routing and searching using radix trees.">

    <meta property="site_name" content="recency-bias">
    <meta property="og:type" content="article">
    <meta property="og:url" content="http://badu.github.io/post/radix-story/">
    <meta property="og:title" content="A Radix Story">
    <meta property="og:image" content="">

    <meta property="og:description" content="About routing and searching using radix trees.">

    <meta name="twitter:url" content="http://badu.github.io/post/radix-story/">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@recency-bias">
    <meta name="twitter:creator" content="@recency-bias">
    <meta name="twitter:title" content="A Radix Story">
    <meta name="twitter:img:src" content="">

    <meta name="twitter:label1" content="Author">
    <meta name="twitter:data1" content="Bogdan Dinu">
    <meta name="twitter:label2" content="Published On">
    <meta name="twitter:data2" content="February 27, 2018">


    <link rel="dns-prefetch" href="//www.google-analytics.com">
    <link rel="dns-prefetch" href="//stats.g.doubleclick.net">

    <link rel="canonical" href="http://badu.github.io/post/radix-story/">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
    <link rel="shortcut icon" href="http://badu.github.io/favicon.ico">

    <style>

    html body {
        font-family: 'Roboto', sans-serif;
        background-color: white;
    }

    :root {
        --accent: #00bcd4;
        --border-width:  5px ;
    }










    </style>


    <link rel="stylesheet" href="/css/main.css">


    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">


    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css">


    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"
          integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"
          integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">


    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/kotlin.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/scala.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/swift.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>


    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"
            integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
            crossorigin="anonymous"></script>

    <script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
    <meta name="generator" content="Hugo 0.31-DEV"/>


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-687869-6"></script>
    <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-687869-6');
          (function() {
          function ready(cb) {
              /in/.test(document.readyState) 
                      ? setTimeout(ready.bind(null, cb), 9)
                      : cb();
          }
          ready(function() {
              
              var indicator = document.querySelector('.scroll-progress');
              if (indicator) {
                  document.addEventListener('scroll', function (e) {
                      var dh = document.body.scrollHeight;
                      var wh = window.innerHeight;
                      var pos = window.scrollY;
                      var footerHeight = 50;
                      var perc = pos / (dh - footerHeight - wh) * 100;
                      indicator.style.setProperty('--scale', (perc / 100));
                  })
              }
              
              var links = document.links;
              for (var i = 0, linksLength = links.length; i < linksLength; i++) {
                  if (links[i].hostname != window.location.hostname) {
                      links[i].target = '_blank';
                  }
              }
          });
          }());










    </script>

</head>

<body>

<nav class="navbar navbar-default navbar-fixed-top">

    <div class="container">

        <div class="navbar-header">

            <a class="navbar-brand visible-xs" href="#">A Radix Story</a>

            <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>

        </div>

        <div class="collapse navbar-collapse">


            <ul class="nav navbar-nav">

                <li><a href="/post/">Posts</a></li>

                <li><a href="/about/">About</a></li>

                <li><a href="/why-recency-bias/">Why Recency Bias?</a></li>

                <li><a href="/hire-me/">Hire me</a></li>

            </ul>


            <ul class="nav navbar-nav navbar-right">

                <li class="navbar-icon"><a href="mailto:badu@badu.ro"><i class="fa fa-envelope-o"></i></a></li>

                <li class="navbar-icon"><a href="https://github.com/badu/"><i class="fa fa-github"></i></a></li>

                <li class="navbar-icon"><a href="https://twitter.com/baduro/"><i class="fa fa-twitter"></i></a></li>

                <li class="navbar-icon"><a href="https://www.linkedin.com/in/flexprogramming/"><i
                        class="fa fa-linkedin"></i></a></li>

                <li>
                    <script type="text/javascript" src="https://secure.skypeassets.com/i/scom/js/skype-uri.js"></script>
                    <div id="SkypeButton_Call_badu.bogdan_1">
                        <script type="text/javascript">
                                         Skype.ui({
                                         "name": "chat",
                                         "element": "SkypeButton_Call_badu.bogdan_1",
                                         "participants": ["badu.bogdan"]
                                         });









                        </script>
                    </div>
                </li>
            </ul>


        </div>

    </div>

    <div class="scroll-progress"></div>
</nav>

<main>
    <div class="item">


        <h4><a href="/post/radix-story/">A Radix Story</a></h4>
        <h5>About routing and searching using radix trees.</h5>
        <h5>February 27, 2018</h5>
        <kbd class="item-tag">Golang</kbd> <kbd class="item-tag">Radix</kbd> <kbd class="item-tag">Tree</kbd> <kbd
            class="item-tag">Router</kbd> <kbd class="item-tag">Search</kbd>
        <p>About 10 minutes of reading.</p>
    </div>

    <br>
    <div class="text-justify">

        <h2 id="a-radix-story">A Radix Story</h2>

        <h4 id="yes-all-you-need-is-standard-net-http">Yes, All You Need is Standard &ldquo;net/http&rdquo;</h4>

        <p>There are, out there in the wild, an abundance of routers that a developer can use. In my opinion, one thing
            that they all share is the lack of separation of concerns. By separation of concerns I mean mixing handlers
            with routes and conditions, putting on top of that some cool optimized algorithm for looking up a route (or
            maybe I should say inspecting a string&hellip;). If you don&rsquo;t need everything those packages provide
            and you feel you should get rid of those training wheels, read on.</p>

        <h4 id="a-small-detour">A Small Detour</h4>

        <p>I should probably write a separate article on the subject of what I consider to be a good Go developer, but
            here is short version of my opinion.</p>

        <p>As you all can observe, the whole variety of packages are competing with each other on the matters of
            allocations and speed. From my point of view this hides a powerful truth about Go language and the
            developers who use it.</p>

        <p>One of the main reasons for switching languages and becoming a Golang developer has to do with speed
            execution. For this reason and this reason only, I think that we can tell a good developer from a mediocre
            one, just by looking at his abilities to use the tools that he has and create new ones specialized for the
            problem that needs a solution.</p>

        <p>Long story short, I strongly believe that a good Golang developer should have a wide enough knowhow and apply
            it whenever needed by adapting a generic solution to a particular case - for the sake of simplicity, speed
            and allocations.</p>

        <h4 id="what-we-are-trying-to-solve">What We Are Trying To Solve?</h4>

        <p>The problem is really simple : let&rsquo;s separate the concerns in such manner that we can adapt a
            sufficient small piece of code to our needs, whatever those needs might be.</p>

        <p>In the case of a router, http.Request gives us access to the requested path. So, if we are able to process
            that path in a way that we need, we might not need a router at all. In the end we should be able to write a
            well anchored set of business logic rules without making the effort to adapt our mental model to a set of
            rules and conventions imposed by the authors of a package.</p>

        <p>To give you a simple example, most routers won&rsquo;t allow you to have a <code>otherwise</code> route :
            match this route with this handler - and so on, but otherwise, put all other requests on this handler. This
            comes handy when you need to cover a dynamic defined route, like serving a request based on the slug of a
            title or the slug of category (title slug being the <code>otherwise</code> handler).</p>

        <p>Let&rsquo;s try to forget about what a route really is, by splitting it into three main properties : a http
            method (GET/POST/PUT/etc.), a path string and a function which needs to be called if that path string looks
            like something particular.</p>

        <p>From now on, we&rsquo;re going to deal with that string only. Leaving the theory alone, the <a
                href="https://en.wikipedia.org/wiki/Radix_tree">applications</a> of a radix tree are constructing a tree
            of pieces of strings which hold a reference to an object (fancy called associative arrays with keys).</p>

        <p>Let&rsquo;s get coding:</p>

        <pre><code class="language-go">    package radix

    type (
        Tree struct {
            root Node
        }

        Edge struct {
            label  string
            parent *Node
            child  *Node
        }
        
        Edges []Edge

        leafNode struct {
            key   string
            value interface{}
        }

        Node struct {
            leaf  *leafNode
            edges Edges
        }
    )
        
    func (n *Node) isLeaf() bool {
        return n.leaf != nil &amp;&amp; len(n.edges) == 0
    }

    func (n *Node) createNode(edgeKey, leafKey string, value interface{}) {
        leafNode := &amp;Node{
            leaf: &amp;leafNode{
                key:   leafKey,
                value: value,
            },
        }
        newEdge := Edge{
            label:  edgeKey,
            parent: n,
            child:  leafNode,
        }
        n.edges = append(n.edges, newEdge)
    }

    func (n *Node) createNodeWithEdges(newKey string, edgeKey string) *Node {
        if n.isLeaf() {
            //node is leaf node could not split, return nil
            return nil
        }

        for idx, edge := range n.edges {
            if edge.label == edgeKey {
                // backup for split
                oldNode := edge.child
                // create a new node
                newNode := &amp;Node{}
                // replace current edge with a new one
                n.edges[idx] = Edge{
                    label:  newKey,
                    parent: n,
                    child:  newNode,
                }
                // connect to original node
                remainKey := strings.TrimPrefix(edgeKey, newKey)
                newEdge := Edge{
                    label:  remainKey,
                    parent: newNode,
                    child:  oldNode,
                }
                // append the edges with that new edge
                newNode.edges = append(newNode.edges, newEdge)
                return newNode
            }
        }
        return nil
    }   
    
    // it's recursive   
    func (t *Tree) insert(target *Node, edgeKey string, leafKey string, value interface{}) {
        // we've reached leaf 
        if target.isLeaf() {
            if leafKey == target.leaf.key {
                // the same leaf key, update value
                // if overwriting values is by convention forbidden, should panic 
                target.leaf.value = value
            } else {
                // insert leaf key value as new child node of target
                // original leaf node, became another leaf of target
                target.createNode(edgeKey, leafKey, value)
                // we have a convention here, regarding empty strings
                target.createNode(&quot;&quot;, target.leaf.key, target.leaf.value)
                target.leaf = nil
            }
            return
        }

        // second case, checking edges
        for _, edge := range target.edges {
            compare, found := longestPrefix(edgeKey, edge.label)
            if found {
                if compare == edge.label {
                    // trim edge.label from new key
                    nextTargetKey := strings.TrimPrefix(edgeKey, edge.label)
                    // recurse
                    t.insert(edge.child, nextTargetKey, leafKey, value)
                } else {
                    // using compare to create new node and separate two edges
                    splitNode := target.createNodeWithEdges(compare, edge.label)
                    if splitNode == nil {
                        panic(&quot;Unexpected error on creating new node and separating edges&quot;)
                    }
                    splitContainKey := strings.TrimPrefix(edgeKey, compare)
                    splitNode.createNode(splitContainKey, leafKey, value)
                }
                return
            }
        }
        // new edge with new leaf key on leaf node
        target.createNode(edgeKey, leafKey, value)
    }

    func (t *Tree) Insert(what string, value interface{}) {
        //leaf key and edge key are the same
        t.insert(&amp;t.root, what, what, value)
    }
    
    func (t *Tree) search(where *Node, what string) (interface{}, bool) {
        if where.isLeaf() {
            return where.leaf.value, true
        }
        for _, edge := range where.edges {
            if compare, found := longestPrefix(what, edge.label); found {
                nextSearchKey := strings.TrimPrefix(what, compare)
                return t.search(edge.child, nextSearchKey)
            }
        }
        return nil, false
    }

    func (t *Tree) Search(what string) (interface{}, bool) {
        return t.search(&amp;t.root, what)
    }
    
    func longestPrefix(s1, s2 string) (string, bool) {
        found := false
        for i := 0; i &lt; len(s1) &amp;&amp; i &lt; len(s2); i++ {
            if s1[i] != s2[i] {
                result := s1[:i]
                return result, found
            }
            found = true
        }

        if len(s1) &gt; len(s2) {
            return s2, found
        } else if len(s1) == len(s2) {
            // special case : &quot;&quot; is not a subset of &quot;&quot;
            return s1, s1 == s2
        }

        return s1, found
    }
</code></pre>

        <p>The code is pretty straight forward, however I&rsquo;ve placed some comments here and there, just in
            case.</p>

        <p>As you can see inside the <a href="https://github.com/badu/badu.github.io/blob/master/code/2/radix_test.go">test</a>,
            I&rsquo;ve tested the search against some HTTP headers, just in case someone might find it useful to discard
            any unwanted headers inside a middleware. Later on, I&rsquo;ll probably benchmark the classical method of
            collecting HTTP headers against this method. However, this is not the point here.</p>

        <p>Usually, we, developers need to match URLs like <code>/posts/{tag}/{id:[0-9]+}</code> in the HTTP path and
            while we&rsquo;re at it also extract those meaningful arguments. Things seem even more complicated when the
            string contains query values, like <code>/posts/{tag}?filter=date&amp;author=3</code>.</p>

        <h4 id="the-star-lookup">The Star Lookup</h4>

        <p>Let&rsquo;s make the following convention : we don&rsquo;t care (at the moment) how an argument look like.
            For us, everything that is an argument is a star (<code>*</code>), leaving the decision of converting and
            validation to the next business logic level (which might be as well the handler itself).</p>

        <p>Given the above convention, the path <code>/posts/{tag}/{id:[0-9]+}</code> would translate to <code>/posts/*/*</code>,
            ok?</p>

        <p>Also, in order to capture the query values <code>/posts/{id:[0-9]+}?filter=date</code> would translate to
            <code>/posts/*?*</code>.</p>

        <p>Here&rsquo;s the code :</p>

        <pre><code class="language-go">    func (e Edge) isStar() bool {
        return strings.HasPrefix(e.label, &quot;*&quot;) || strings.HasPrefix(e.label, &quot;/*&quot;) || strings.HasPrefix(e.label, &quot;?*&quot;)
    }

    func (t *Tree) starSearch(where *Node, what string) (interface{}, bool) {
        if where.isLeaf() {
            return where.leaf.value, true
        }

        for _, edge := range where.edges {
            if edge.isStar() {
                // search key is empty and we're on the &quot;/*&quot; means we're looking for the last sibling of the edge
                if what == &quot;&quot; &amp;&amp; strings.HasPrefix(edge.label, &quot;/*&quot;) {
                    continue
                }
                // different kind of star... (&quot;*&quot; or &quot;?*&quot;)

                // remove the common parts
                remove, found := longestPrefix(what, edge.label)
                if found {
                    what = strings.TrimPrefix(what, remove)
                }

                // split by slashes so we can build a new key
                parts := strings.Split(what, &quot;/&quot;)

                switch len(parts) {
                case 1:
                    // ok, we had one piece
                    // looking for the question mark - might be handy to give up on this for speed
                    index := strings.Index(what, &quot;?&quot;)
                    if index &gt; 0 {
                        //TODO : collect star key after question mark
                        fmt.Println(&quot;Collect after question mark &quot;, what[index:])
                        // lookup question marks - down in the tree
                        return t.starSearch(edge.child, what[index:])
                    }
                    // don't have a question mark, but we have a star (continue) - looking for the last sibling edge
                    if strings.HasPrefix(edge.label, &quot;?*&quot;) &amp;&amp; remove != &quot;?&quot; {
                        continue
                    }
                    //TODO : collect star key
                    fmt.Println(&quot;Collect Path Part&quot;, what)
                    // we have a star, no question mark - looking for the node leaf
                    return t.starSearch(edge.child, &quot;&quot;)
                default:
                    //TODO : collect star key part of the path
                    fmt.Println(&quot;Collect Path Part&quot;, parts[0])
                    // building a new key with the parts that we have
                    what = strings.Join(parts[1:], &quot;/&quot;)
                    return t.starSearch(edge.child, what)
                }
            }

            if compare, found := longestPrefix(what, edge.label); found {
                nextSearchKey := strings.TrimPrefix(what, compare)
                return t.starSearch(edge.child, nextSearchKey)
            }
        }

        return nil, false
    }

    func (t *Tree) StarSearch(what string) (interface{}, bool) {
        // TODO : use a mutex here if you are using this concurrent
        return t.starSearch(&amp;t.root, what)
    }
</code></pre>

        <p>Remember, you have to adapt this to your specific needs and for this reason I haven&rsquo;t imposed a way of
            capturing path parts that match star (<code>*</code>). I&rsquo;ve left comments where you can do that.</p>

        <p>In the above starSearch function there is a catch : if the edges slice is not sorted, so the last sibling is
            the star (<code>*</code>), the search will not work. To sort those slices, we need the following:</p>

        <pre><code class="language-go">    func (e Edges) Len() int {
        return len(e)
    }

    func (e Edges) Less(i, j int) bool {
        return e[i].label &gt; e[j].label
    }

    func (e Edges) Swap(i, j int) {
        e[i], e[j] = e[j], e[i]
    }

    func (e Edges) Sort() {
        sort.Sort(e)
    }
</code></pre>

        <p>The functions createNode and createNodeWithEdges will have the following additional piece of code:</p>

        <pre><code class="language-go">    if useSortEdges {
        // we're always sorting in reverse, so stars are last siblings
        newNode.edges.Sort()
    }
</code></pre>

        <h4 id="recommendations">Recommendations</h4>

        <p>First, don&rsquo;t forget to use mutex for search - I&rsquo;ve left a comment there - if you are using it in
            a concurrent way.</p>

        <p>Secondly, the problem of defining one route is that you can&rsquo;t do this <code>/*/*</code> and expect it
            to work only in one route. In order to make it work you need an <code>exception string</code> (see
            TestStarOneRoute) and that exception string to look like <code>*/something-never-matched</code>.</p>

        <p>Regarding leafNode struct value property, which is typed <code>interface{}</code> in the above code - you
            should do whatever you like with it. To give you an obvious example:</p>

        <pre><code class="language-go">    leafNode struct {
        key   string
        value http.HandlerFunc
    }
</code></pre>

        <p>Last, but not least, you can alter things like adding a flag to the tree to mark it as dirty, then process
            all the edges in the tree and mark them as isStar <code>true/false</code> so <code>isStar() bool</code>
            function can be replaced like that. Or you could rewrite some parts to reduce allocations.</p>

        <h4 id="other-usages">Other usages</h4>

        <p>Besides request routing, radix trees can be used in building ACLs (storing capabilities/permissions in the
            <code>value</code> property), spell checkers, auto-complete suggestions and <a
                    href="https://github.com/hashicorp/go-memdb">in memory database</a>.</p>

        <h4 id="code">Code</h4>

        <p>The complete code (tests included) is <a href="https://github.com/badu/badu.github.io/blob/master/code/2">here</a>.
        </p>
    </div>


    <h4 class="page-header">Related</h4>
    <div class="item">


        <h4><a href="/post/mirror-mirror/">Mirror Mirror on ...</a></h4>
        <h5>Of Mice (Unsafe) and Men (Reflect)</h5>
        <h5>March 10, 2018</h5>
        <kbd class="item-tag">Golang</kbd> <kbd class="item-tag">Advanced</kbd> <kbd class="item-tag">Reflect</kbd> <kbd
            class="item-tag">Unsafe</kbd>
        <p>About 12 minutes of reading.</p>
    </div>
    <div class="item">


        <h4><a href="/post/known-world-stops/">Knowing when the world stops</a></h4>
        <h5>I quote &#34;This function is called with the world stopped, at the beginning of a garbage
            collection.&#34;</h5>
        <h5>March 5, 2018</h5>
        <kbd class="item-tag">Golang</kbd> <kbd class="item-tag">Advanced</kbd> <kbd class="item-tag">Compiler</kbd>
        <kbd class="item-tag">Directives</kbd>
        <p>About 3 minutes of reading.</p>
    </div>
    <div class="item">


        <h4><a href="/post/net-http-week2/">My Thoughts On Net/Http Package - Week 2</a></h4>
        <h5>A deep dive into it net/http package.</h5>
        <h5>February 24, 2018</h5>
        <kbd class="item-tag">Golang</kbd> <kbd class="item-tag">Net</kbd> <kbd class="item-tag">Http</kbd> <kbd
            class="item-tag">Analysis</kbd>
        <p>About 5 minutes of reading.</p>
    </div>


    <h4 class="page-header">Comments</h4>
    <div id="disqus_thread"></div>
    <script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "recency-bias" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();

    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by
        Disqus.</a></noscript>
    <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

</main>
<footer>
    <p class="copyright text-muted"> Recency Bias &copy; 2017
        - Powered by <a href="https://gohugo.io">Hugo</a>.</p>
</footer>
</body>
</html>

